@page "/chat"
@rendermode InteractiveServer
@using Cooney.AI.Services
@using Microsoft.Extensions.AI
@using System.Text
@inject IChatService ChatService
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<PageTitle>AI Chat</PageTitle>

<FluentStack Orientation="Orientation.Vertical" VerticalGap="16" Style="height: calc(100vh - 200px);">
	<FluentStack Orientation="Orientation.Horizontal">
		<h2>AI Assistant</h2>
		<FluentSpacer />
        <FluentButton Appearance="Appearance.Outline"
					  OnClick="ClearChat"
                      Disabled="@(isProcessing || isCancelling)"
					  IconStart="@(new Icons.Regular.Size20.Delete())">
			Clear Chat
		</FluentButton>
	</FluentStack>
	<!-- Message History Display -->
	<FluentStack Id="@CONTAINER_ID"
				 Orientation="Orientation.Vertical"
				 VerticalGap="12"
				 Style="flex: 1; overflow-y: auto; padding: 16px; border: 1px solid var(--neutral-stroke-rest);">

		@foreach (var message in ChatService.ChatHistory.Where(m => m.Role != ChatRole.System))
		{
			<ChatMessageDisplay Message="@message" />
		}

        @if (isProcessing)
		{
			<ChatMessageDisplay Message="@streamingMessage" IsStreaming="true" />
		}

	</FluentStack>

	<!-- Input Area -->
	<FluentStack Orientation="Orientation.Horizontal" VerticalGap="8" Style="width: 100%;">
		<FluentTextField @bind-Value="userInput"
						Placeholder="Type your message here..."
						Style="flex: 1;"
						@onkeydown="HandleKeyDown">
		</FluentTextField>

		<FluentButton Appearance="Appearance.Accent"
					 OnClick="SendMessage"
                     Disabled="@(isProcessing || isCancelling)"
					 IconStart="@(new Icons.Regular.Size20.Send())">
			Send
		</FluentButton>

		<FluentButton Appearance="Appearance.Outline"
					  OnClick="CancelGeneration"
                      Disabled="@(!isProcessing || isCancelling)"
					  IconStart="@(new Icons.Regular.Size20.Dismiss())">
			Cancel
		</FluentButton>

        <FluentProgressRing Value="@ContextPercentage"
                            Width="32px"
                            Stroke="ProgressStroke.Normal"/>
	</FluentStack>

	@if (!string.IsNullOrEmpty(errorMessage))
	{
		<FluentMessageBar Title="Error"
						 Intent="MessageIntent.Error"
						 OnDismiss="() => errorMessage = string.Empty">
			@errorMessage
		</FluentMessageBar>
	}

</FluentStack>

@code {
    private string userInput = string.Empty;
    private bool isProcessing = false;
    private bool isCancelling = false;
    private string errorMessage = string.Empty;
    private CancellationTokenSource? _cancellationTokenSource;
    private ChatMessage streamingMessage = new ChatMessage(ChatRole.Assistant, string.Empty);

    // JavaScript interop for scrolling
    private IJSObjectReference? _jsModule;
    private const string CONTAINER_ID = "chat-messages-container";

    private int ContextPercentage => ChatService.ContextLength > 0
        ? (int)Math.Round((double)ChatService.TotalTokenCount / ChatService.ContextLength * 100)
        : 0;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import",
                "./Components/Pages/Chat.razor.js");

            // Scroll to bottom if there's existing history
            // No delay needed here - the DOM is already rendered
            if (ChatService.ChatHistory.Any(m => m.Role != ChatRole.System))
            {
                await ScrollToBottomAsync(force: true);
            }
        }
    }

    private async Task ScrollToBottomAsync(bool force = false)
    {
        if (_jsModule == null) return;

        // Check if user manually scrolled up (skip auto-scroll unless forced)
        if (!force)
        {
            var userScrolledUp = await _jsModule.InvokeAsync<bool>("isUserScrolledUp", CONTAINER_ID);
            if (userScrolledUp) return;
        }

        // Perform scroll (instant to avoid animation stacking)
        await _jsModule.InvokeVoidAsync("scrollToBottom", CONTAINER_ID, false);
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(userInput) || isProcessing)
            return;

        var message = userInput;
        userInput = string.Empty;
        isProcessing = true;
        errorMessage = string.Empty;

        // Scroll to show user message
        // StateHasChanged();
        // await ScrollToBottomAsync(force: true);

        // Create new cancellation token source for this request
        _cancellationTokenSource = new CancellationTokenSource();
        var chunksSinceLastScroll = 0;

        try
        {
            await foreach (var update in ChatService.SendMessageAsync(message, _cancellationTokenSource.Token))
            {
                if (update.Contents.OfType<TextContent>().FirstOrDefault() is TextContent content)
                {
                    // streamingMessageBuilder.Append(update.Text);
                    streamingMessage.Contents.Add(content);

                    // Throttled scroll: only every N chunks
                    chunksSinceLastScroll++;
                    if (chunksSinceLastScroll >= 10) // Scroll every n chunks
                    {
                        StateHasChanged();
                        await ScrollToBottomAsync(force: false);
                        chunksSinceLastScroll = 0;
                    }
                    else
                    {
                        StateHasChanged();
                    }
                }
            }

            // Message is now in history, clear the streaming message
            streamingMessage.Contents.Clear();

            // Final scroll to ensure complete message is visible
            StateHasChanged();
            await ScrollToBottomAsync(force: true);
        }
        catch (OperationCanceledException)
        {
            streamingMessage.Contents.Clear();
        }
        catch (Exception ex)
        {
            errorMessage = $"Error: {ex.Message}";
        }
        finally
        {
            // Dispose the cancellation token source
            if (_cancellationTokenSource != null)
            {
                _cancellationTokenSource.Dispose();
                _cancellationTokenSource = null;
                isCancelling = false;
            }
            isProcessing = false;
            StateHasChanged();
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
        }
    }

    private async Task ClearChat()
    {
        ChatService.ClearHistory();
        streamingMessage.Contents.Clear();
        errorMessage = string.Empty;
        StateHasChanged();

        // Reset scroll position
        await ScrollToBottomAsync(force: true);
    }

    private async Task CancelGeneration()
    {
        isCancelling = true;
        _cancellationTokenSource?.Cancel();
		userInput = string.Empty;

		// Scroll to show the partial message
		await ScrollToBottomAsync(force: true);
	}

	public async ValueTask DisposeAsync()
	{
		if (_cancellationTokenSource != null)
		{
			_cancellationTokenSource.Cancel();
			_cancellationTokenSource.Dispose();
			_cancellationTokenSource = null;
		}

		if (_jsModule != null)
		{
			await _jsModule.DisposeAsync();
		}
	}
}
