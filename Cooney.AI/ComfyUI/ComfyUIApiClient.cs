using CommunityToolkit.Diagnostics;
using Microsoft.Extensions.AI;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.Json.Nodes;

namespace Cooney.AI.ComfyUI;

public class ComfyUIApiClient : IImageGenerator
{
	private static readonly Random _random = new();

	private readonly HttpClient _httpClient;
	private readonly string _serverAddress;

	public static readonly ImageGenerationOptions DefaultImageGenerationOptions = new()
	{
		AdditionalProperties = new()
		{
			{ "workflow", null },
			{ "steps", 20 },
			{ "cfg_scale", 1.0 },
			{ "guidance_scale", 3.5 },
			{ "seed", -1 },
		},
		Count = 1,
		ImageSize = new(1024, 1024),
		MediaType = "image/png",
		ModelId = "flux1-dev-fp8.safetensors",
		ResponseFormat = ImageGenerationResponseFormat.Data,
	};

	/// <summary>
	/// Initializes a new instance of the ComfyUIClient.
	/// </summary>
	/// <param name="serverAddress">The ComfyUI server address (default: http://127.0.0.1:8188)</param>
	public ComfyUIApiClient(string serverAddress = "http://127.0.0.1:8188")
	{
		_serverAddress = serverAddress.TrimEnd('/');
		_httpClient = new HttpClient { BaseAddress = new Uri(_serverAddress) };
	}

	public async Task<ImageGenerationResponse> GenerateAsync(ImageGenerationRequest request, ImageGenerationOptions? options = null, CancellationToken cancellationToken = default)
	{
		int pollingIntervalMs = 3000;
		int timeoutMs = 240_000;

		IWorkflow workflow;
		if (options != null &&
			options.AdditionalProperties != null &&
			options.AdditionalProperties.TryGetValue("workflow", out var workflowObj) &&
			workflowObj is IWorkflow customWorkflow)
		{
			workflow = customWorkflow;
		}
		else
		{
			workflow = BuildFluxWorkflow(request, options);
		}

		// Queue the workflow
		var promptId = await QueuePromptAsync(workflow.Build(), cancellationToken: cancellationToken);

		// Wait for completion
		var finalStatus = await WaitForCompletionAsync(promptId, pollingIntervalMs, timeoutMs, cancellationToken);

		// Extract and download the generated image
		var image = await ExtractAndDownloadImageAsync(promptId, finalStatus, cancellationToken);

		return new ImageGenerationResponse
		{
			RawRepresentation = image,
		};
	}

	public object? GetService(Type serviceType, object? serviceKey = null)
	{
		if (serviceType == typeof(IImageGenerator))
		{
			return this;
		}

		return null;
	}

	void IDisposable.Dispose()
	{
		_httpClient?.Dispose();
	}

	private async Task<JsonNode> WaitForCompletionAsync(
		string promptId,
		int pollingIntervalMs,
		int timeoutMs,
		CancellationToken cancellationToken)
	{
		var maxAttempts = timeoutMs / pollingIntervalMs;
		var attempt = 0;

		while (attempt < maxAttempts)
		{
			await Task.Delay(pollingIntervalMs, cancellationToken);

			var status = await GetPromptStatusAsync(promptId, cancellationToken);

			// Check if the prompt is in the history (meaning it completed)
			if (status?[promptId] != null)
			{
				return status;
			}

			attempt++;
		}

		throw new TimeoutException($"Image generation did not complete within {timeoutMs}ms");
	}

	private async Task<byte[]> ExtractAndDownloadImageAsync(
		string promptId,
		JsonNode finalStatus,
		CancellationToken cancellationToken)
	{
		var outputs = finalStatus[promptId]?["outputs"] ?? throw new InvalidOperationException("No outputs found in the workflow result");

		// Iterate through all output nodes to find the first image
		foreach (var outputNode in outputs.AsObject())
		{
			var images = outputNode.Value?["images"]?.AsArray();
			if (images != null && images.Count > 0)
			{
				var imageInfo = images[0];
				var filename = imageInfo?["filename"]?.GetValue<string>();
				var subfolder = imageInfo?["subfolder"]?.GetValue<string>();
				var type = imageInfo?["type"]?.GetValue<string>() ?? "output";

				if (!string.IsNullOrEmpty(filename))
				{
					return await GetImageAsync(filename!, subfolder, type, cancellationToken);
				}
			}
		}

		throw new InvalidOperationException("No image was generated by the workflow");
	}

	/// <summary>
	/// Queues a prompt (workflow) for execution on the ComfyUI server.
	/// </summary>
	/// <param name="workflow">The workflow JSON as a JsonNode or dictionary</param>
	/// <param name="clientId">Optional client ID for WebSocket tracking</param>
	/// <param name="apiKey">Optional ComfyUI API key for external API nodes</param>
	/// <param name="cancellationToken">Cancellation token</param>
	/// <returns>The prompt ID assigned by the server</returns>
	private async Task<string> QueuePromptAsync(
		JsonNode workflow,
		string? clientId = null,
		string? apiKey = null,
		CancellationToken cancellationToken = default)
	{
		var payload = new JsonObject
		{
			["prompt"] = workflow
		};

		if (!string.IsNullOrEmpty(clientId))
		{
			payload["client_id"] = clientId;
		}

		if (!string.IsNullOrEmpty(apiKey))
		{
			payload["extra_data"] = new JsonObject
			{
				["api_key_comfy_org"] = apiKey
			};
		}

		var content = new StringContent(
			payload.ToJsonString(),
			Encoding.UTF8,
			"application/json");

		var response = await _httpClient.PostAsync("/prompt", content, cancellationToken);
		response.EnsureSuccessStatusCode();

		var responseJson = await response.Content.ReadAsStringAsync();
		var responseObj = JsonNode.Parse(responseJson) ?? throw new InvalidOperationException("Failed to parse response");

		return responseObj["prompt_id"]?.GetValue<string>()
			?? throw new InvalidOperationException("Failed to get prompt_id from server response");
	}

	/// <summary>
	/// Gets the status of a queued prompt.
	/// </summary>
	/// <param name="promptId">The prompt ID to check</param>
	/// <param name="cancellationToken">Cancellation token</param>
	/// <returns>The prompt status information</returns>
	private async Task<JsonNode> GetPromptStatusAsync(string promptId, CancellationToken cancellationToken = default)
	{
		var response = await _httpClient.GetAsync($"/history/{promptId}", cancellationToken);
		response.EnsureSuccessStatusCode();

		var content = await response.Content.ReadAsStringAsync();
		return JsonNode.Parse(content) ?? throw new InvalidOperationException("Failed to parse history response");
	}

	/// <summary>
	/// Retrieves system statistics from the ComfyUI server.
	/// </summary>
	/// <param name="cancellationToken">Cancellation token</param>
	/// <returns>System stats as a JsonNode if successful, null if the server is not reachable</returns>
	public async Task<JsonNode?> GetSystemStatsAsync(CancellationToken cancellationToken = default)
	{
		try
		{
			var response = await _httpClient.GetAsync("/system_stats", cancellationToken);

			if (!response.IsSuccessStatusCode)
				return null;

			var content = await response.Content.ReadAsStringAsync();
			return JsonNode.Parse(content);
		}
		catch (Exception)
		{
			return null;
		}
	}

	/// <summary>
	/// Retrieves the list of available node types from the ComfyUI server.
	/// </summary>
	/// <param name="cancellationToken">Cancellation token</param>
	/// <returns>A list of node type names (e.g., "KSampler", "CheckpointLoaderSimple")</returns>
	public async Task<List<string>> GetNodeTypesAsync(CancellationToken cancellationToken = default)
	{
		var response = await _httpClient.GetAsync("/object_info", cancellationToken);
		response.EnsureSuccessStatusCode();

		var content = await response.Content.ReadAsStringAsync();
		var objectInfo = JsonNode.Parse(content)
			?? throw new InvalidOperationException("Failed to parse object_info response");

		return [.. objectInfo.AsObject().Select(kvp => kvp.Key)];
	}

	/// <summary>
	/// Retrieves the list of all available models from the ComfyUI server across all model folders.
	/// </summary>
	/// <param name="cancellationToken">Cancellation token</param>
	/// <returns>A list of all model filenames (e.g., "flux1-dev-fp8.safetensors", "umt5_xxl_fp8_e4m3fn_scaled.safetensors")</returns>
	public async Task<List<string>> GetModelsAsync(CancellationToken cancellationToken = default)
	{
		// Get all model folder names
		var foldersResponse = await _httpClient.GetAsync("/models", cancellationToken);
		foldersResponse.EnsureSuccessStatusCode();

		var foldersContent = await foldersResponse.Content.ReadAsStringAsync();
		var folders = JsonNode.Parse(foldersContent)
			?? throw new InvalidOperationException("Failed to parse models folder response");

		var folderNames = folders.AsArray()
			.Select(node => node?.GetValue<string>())
			.Where(name => !string.IsNullOrEmpty(name))
			.Where(name => !name!.Equals("custom_nodes", StringComparison.OrdinalIgnoreCase))
			.ToList();

		// Get models from each folder
		var allModels = new List<string>();

		foreach (var folder in folderNames)
		{
			var modelsResponse = await _httpClient.GetAsync($"/models/{folder}", cancellationToken);
			modelsResponse.EnsureSuccessStatusCode();

			var modelsContent = await modelsResponse.Content.ReadAsStringAsync();
			var models = JsonNode.Parse(modelsContent)
				?? throw new InvalidOperationException($"Failed to parse models response for folder: {folder}");

			var modelNames = models.AsArray()
				.Select(node => node?.GetValue<string>())
				.Where(name => !string.IsNullOrEmpty(name))
				.Select(name => name!);

			allModels.AddRange(modelNames);
		}

		return allModels;
	}

	/// <summary>
	/// Uploads an image to the ComfyUI server.
	/// </summary>
	/// <param name="imageData">The image data as a byte array</param>
	/// <param name="filename">The filename to use for the uploaded image</param>
	/// <param name="overwrite">Whether to overwrite an existing file with the same name</param>
	/// <param name="subfolder">Optional subfolder to upload the image to</param>
	/// <param name="cancellationToken">Cancellation token</param>
	/// <returns>The uploaded image information including name and subfolder</returns>
	public async Task<(string name, string subfolder, string type)> UploadImageAsync(
		byte[] imageData,
		string filename,
		bool overwrite = true,
		string? subfolder = null,
		CancellationToken cancellationToken = default)
	{
		using var content = new MultipartFormDataContent();

		var imageContent = new ByteArrayContent(imageData);
		imageContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("image/png");
		content.Add(imageContent, "image", filename);

		if (overwrite)
		{
			content.Add(new StringContent("true"), "overwrite");
		}

		if (!string.IsNullOrEmpty(subfolder))
		{
			content.Add(new StringContent(subfolder), "subfolder");
		}

		var response = await _httpClient.PostAsync("/upload/image", content, cancellationToken);
		response.EnsureSuccessStatusCode();

		var responseJson = await response.Content.ReadAsStringAsync();
		var responseObj = JsonNode.Parse(responseJson) ?? throw new InvalidOperationException("Failed to parse upload response");

		var name = responseObj["name"]?.GetValue<string>()
			?? throw new InvalidOperationException("Failed to get name from upload response");
		var uploadedSubfolder = responseObj["subfolder"]?.GetValue<string>() ?? string.Empty;
		var type = responseObj["type"]?.GetValue<string>() ?? "input";

		return (name, uploadedSubfolder, type);
	}

	/// <summary>
	/// Retrieves generated images from the server.
	/// </summary>
	/// <param name="filename">The filename of the image</param>
	/// <param name="subfolder">The subfolder containing the image</param>
	/// <param name="folderType">The folder type (e.g., "output", "temp")</param>
	/// <param name="cancellationToken">Cancellation token</param>
	/// <returns>The image data as a byte array</returns>
	private async Task<byte[]> GetImageAsync(
		string filename,
		string? subfolder = null,
		string folderType = "output",
		CancellationToken cancellationToken = default)
	{
		var query = $"?filename={Uri.EscapeDataString(filename)}&type={folderType}";

		if (!string.IsNullOrEmpty(subfolder))
		{
			query += $"&subfolder={Uri.EscapeDataString(subfolder)}";
		}

		var response = await _httpClient.GetAsync($"/view{query}", cancellationToken);
		response.EnsureSuccessStatusCode();

		return await response.Content.ReadAsByteArrayAsync();
	}

	private static IWorkflow BuildFluxWorkflow(ImageGenerationRequest request, ImageGenerationOptions? options = null)
	{
		options ??= DefaultImageGenerationOptions;

		var width = options.ImageSize!.Value.Width;
		var height = options.ImageSize!.Value.Height;
		var checkpointName = !string.IsNullOrEmpty(options.ModelId)
			? options.ModelId
			: "flux1-dev-fp8.safetensors";

		Guard.IsNotNull(options.AdditionalProperties);

		var negativePrompt = options.AdditionalProperties.TryGetValue("negative_prompt", out var negPromptObj)
			? negPromptObj?.ToString() ?? string.Empty
			: string.Empty;
		var steps = options.AdditionalProperties.TryGetValue("steps", out var stepsObj) && int.TryParse(stepsObj?.ToString(), out var stepsVal)
			? stepsVal
			: 20;
		var cfg = options.AdditionalProperties.TryGetValue("cfg_scale", out var cfgObj) && double.TryParse(cfgObj?.ToString(), out var cfgVal)
			? cfgVal
			: 1.0;
		var guidance = options.AdditionalProperties.TryGetValue("guidance_scale", out var guidanceObj) && double.TryParse(guidanceObj?.ToString(), out var guidanceVal)
			? guidanceVal
			: 3.5;
		var seed = options.AdditionalProperties.TryGetValue("seed", out var seedObj) && int.TryParse(seedObj?.ToString(), out var seedVal)
			? seedVal
			: -1;

		if (seed < 0)
			seed = _random.Next();

		var node = JsonNode.Parse($$"""
		{
			"6": {
				"inputs": {
					"text": "{{request.Prompt}}",
					"clip": ["30", 1]
				},
				"class_type": "CLIPTextEncode",
				"_meta": {
					"title": "CLIP Text Encode (Positive Prompt)"
				}
			},
			"8": {
				"inputs": {
					"samples": ["31", 0],
					"vae": ["30", 2]
				},
				"class_type": "VAEDecode",
				"_meta": {
					"title": "VAE Decode"
				}
			},
			"9": {
				"inputs": {
					"filename_prefix": "ComfyUI",
					"images": ["8", 0]
				},
				"class_type": "SaveImage",
				"_meta": {
					"title": "Save Image"
				}
			},
			"27": {
				"inputs": {
					"width": {{width}},
					"height": {{height}},
					"batch_size": 1
				},
				"class_type": "EmptySD3LatentImage",
				"_meta": {
					"title": "EmptySD3LatentImage"
				}
			},
			"30": {
				"inputs": {
					"ckpt_name": "{{checkpointName}}"
				},
				"class_type": "CheckpointLoaderSimple",
				"_meta": {
					"title": "Load Checkpoint"
				}
			},
			"31": {
				"inputs": {
					"seed": {{seed}},
					"steps": {{steps}},
					"cfg": {{cfg}},
					"sampler_name": "euler",
					"scheduler": "simple",
					"denoise": 1,
					"model": ["30", 0],
					"positive": ["35", 0],
					"negative": ["33", 0],
					"latent_image": ["27", 0]
				},
				"class_type": "KSampler",
				"_meta": {
					"title": "KSampler"
				}
			},
			"33": {
				"inputs": {
					"text": "{{negativePrompt}}",
					"clip": ["30", 1]
				},
				"class_type": "CLIPTextEncode",
				"_meta": {
					"title": "CLIP Text Encode (Negative Prompt)"
				}
			},
			"35": {
				"inputs": {
					"guidance": {{guidance}},
					"conditioning": ["6", 0]
				},
				"class_type": "FluxGuidance",
				"_meta": {
					"title": "FluxGuidance"
				}
			}
		}
		""") ?? throw new InvalidOperationException("Failed to parse workflow JSON");

		return new Workflow("Flux Workflow", node);
	}
}
