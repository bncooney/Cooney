using Cooney.AI.SourceGenerators.Models;
using System.Reflection.Metadata;
using System.Text;

namespace Cooney.AI.SourceGenerators;

/// <summary>
/// Generates C# source code for workflow classes.
/// </summary>
internal static class WorkflowCodeGenerator
{
	/// <summary>
	/// Generates a complete C# class implementing IWorkflow for the given workflow model.
	/// </summary>
	public static string Generate(WorkflowModel workflow)
	{
		var className = ToClassName(workflow.Name);
		var sb = new StringBuilder();

		// File header
		sb.AppendLine("// <auto-generated />");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
		sb.AppendLine("namespace Cooney.AI.Workflows.Generated;");
		sb.AppendLine();

		// Class declaration
		sb.AppendLine("/// <summary>");
		sb.AppendLine($"/// Workflow generated from {Path.GetFileName(workflow.FilePath)}.");
		sb.AppendLine("/// </summary>");
		sb.AppendLine($"public sealed class {className} : global::Cooney.AI.IWorkflow");
		sb.AppendLine("{");

		// Name property
		sb.AppendLine($"\tpublic string Name => \"{workflow.Name}\";");
		sb.AppendLine();

		// Parameter properties
		foreach (var parameter in workflow.Parameters)
		{
			var propertyName = ToPascalCase(parameter);
			sb.AppendLine($"\tpublic string {propertyName} {{ get; set; }}");
			sb.AppendLine();
		}

		// Constructor
		if (workflow.Parameters.Count > 0)
		{
			GenerateConstructor(sb, className, workflow.Parameters);
			sb.AppendLine();
		}

		// Build method
		GenerateBuildMethod(sb, workflow.Parameters);
		sb.AppendLine();

		// Template constant
		GenerateTemplateConstant(sb, workflow.JsonTemplate);

		sb.AppendLine("}");

		return sb.ToString();
	}

	/// <summary>
	/// Generates the constructor for the workflow class.
	/// </summary>
	private static void GenerateConstructor(StringBuilder sb, string className, IReadOnlyList<string> parameters)
	{
		sb.Append($"\tpublic {className}(");

		// Constructor parameters
		var constructorParams = new List<string>();
		foreach (var parameter in parameters)
		{
			var paramName = ToCamelCase(parameter);
			constructorParams.Add($"string {paramName}");
		}
		sb.Append(string.Join(", ", constructorParams));
		sb.AppendLine(")");

		sb.AppendLine("\t{");

		// Assign parameters to properties
		foreach (var parameter in parameters)
		{
			var propertyName = ToPascalCase(parameter);
			var paramName = ToCamelCase(parameter);
			sb.AppendLine($"\t\t{propertyName} = {paramName};");
		}

		sb.AppendLine("\t}");
	}

	/// <summary>
	/// Generates the Build method that substitutes parameters into the JSON template and returns a JsonNode.
	/// </summary>
	private static void GenerateBuildMethod(StringBuilder sb, IReadOnlyList<string> parameters)
	{
		sb.AppendLine("\tpublic global::System.Text.Json.Nodes.JsonNode Build()");
		sb.AppendLine("\t{");

		if (parameters.Count > 0)
		{
			sb.AppendLine("\t\tvar json = TemplateJson;");

			foreach (var parameter in parameters)
			{
				var propertyName = ToPascalCase(parameter);
				sb.AppendLine($"\t\tjson = json.Replace(\"{{{{{parameter}}}}}\", {propertyName});");
			}
			sb.AppendLine($"\t\tjson = json.Replace(\"8675309\", new global::System.Random().Next().ToString());");

			sb.AppendLine("\t\treturn global::System.Text.Json.Nodes.JsonNode.Parse(json)!;");
		}
		else
		{
			sb.AppendLine("\t\treturn global::System.Text.Json.Nodes.JsonNode.Parse(TemplateJson)!;");
		}

		sb.AppendLine("\t}");
	}

	/// <summary>
	/// Generates the private constant containing the JSON template.
	/// </summary>
	private static void GenerateTemplateConstant(StringBuilder sb, string jsonTemplate)
	{
		// Escape the JSON template for use in a verbatim string literal
		var escapedJson = jsonTemplate.Replace("\"", "\"\"");

		sb.AppendLine("\tprivate const string TemplateJson = @\"");
		sb.Append(escapedJson);
		sb.AppendLine("\";");
	}

	/// <summary>
	/// Converts a workflow name to a valid C# class name in PascalCase.
	/// </summary>
	private static string ToClassName(string workflowName)
	{
		var className = ToPascalCase(workflowName);
		return $"{className}Workflow";
	}

	/// <summary>
	/// Converts a parameter name to PascalCase for property names.
	/// </summary>
	private static string ToPascalCase(string input)
	{
		if (string.IsNullOrEmpty(input))
			return input;

		// Remove special characters and split on word boundaries
		var words = SplitIntoWords(input);
		var sb = new StringBuilder();

		foreach (var word in words)
		{
			if (word.Length > 0)
			{
				sb.Append(char.ToUpperInvariant(word[0]));
				if (word.Length > 1)
				{
					sb.Append(word.Substring(1).ToLowerInvariant());
				}
			}
		}

		return sb.ToString();
	}

	/// <summary>
	/// Converts a parameter name to camelCase for constructor parameters.
	/// </summary>
	private static string ToCamelCase(string input)
	{
		var pascalCase = ToPascalCase(input);
		if (string.IsNullOrEmpty(pascalCase))
			return pascalCase;

		return char.ToLowerInvariant(pascalCase[0]) + pascalCase.Substring(1);
	}

	/// <summary>
	/// Splits a string into words based on various delimiters and casing patterns.
	/// </summary>
	private static IEnumerable<string> SplitIntoWords(string input)
	{
		var words = new List<string>();
		var currentWord = new StringBuilder();

		for (int i = 0; i < input.Length; i++)
		{
			var c = input[i];

			if (char.IsLetterOrDigit(c))
			{
				// Handle camelCase/PascalCase transitions
				if (currentWord.Length > 0 && char.IsUpper(c) && i > 0 && char.IsLower(input[i - 1]))
				{
					words.Add(currentWord.ToString());
					currentWord.Clear();
				}

				currentWord.Append(c);
			}
			else
			{
				// Non-alphanumeric character - treat as word boundary
				if (currentWord.Length > 0)
				{
					words.Add(currentWord.ToString());
					currentWord.Clear();
				}
			}
		}

		if (currentWord.Length > 0)
		{
			words.Add(currentWord.ToString());
		}

		return words;
	}
}
